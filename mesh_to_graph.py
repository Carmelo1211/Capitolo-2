# -*- coding: utf-8 -*-
"""Mesh_to_Graph.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GVKzTFRhSCr_ElawKIXje7csdk57I9sx

Capitolo 2
"""

#!pip install meshio
import meshio
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

mesh = meshio.read(r"C:\Users\aliac\Desktop\Tesi_Magistrale\Esercitazione_CFD\Euler_2D\bump_structured.msh")  # Carico la mesh dal file .msh


edges = set() # Utilizzo un set() perchè elimina automaticamente i duplicati


# All'interno del dizionario  mesh.cells_dict si trova come chiave il tipo di cella ( triangolare, quadrata ..) mentre come valore si trova un array il cui numero di righe rappresenta
# il numero di quella tipologia di celle mentre come colonne i punti che compongono le rispettive celle


for cell_type, cell_array in mesh.cells_dict.items():
    for elem in cell_array:
        m = len(elem)
        if m >= 2:                       # salta gli elementi che hanno solo un punto
          for i in range(m):
                a = int(elem[i])
                b = int(elem[(i+1) % m])  # collega il nodo i finale chiudendolo con il primo
                edge = (min(a, b), max(a, b)) # si evitano i duplicati tipo (6,2)=(2,6) perchè si sta usando un grafo senza direzione
                edges.add(edge)


edge_list = list(edges)  # Converto il set in lista

# Creo il Grafo dalla lista degli archi
G = nx.Graph()
G.add_edges_from(edge_list)

# Per avere una rappresentazione del grafo cooerente con quella della mesh computazionale estraggo le coordinate (array N×3)
points = mesh.points
coords_2d = points[:, :2]     # essendo la mesh 2D prendo solo (x,y)

# Creo un dizionario {node_id: (x,y)}
coords_dict = {}
for i in range(coords_2d.shape[0]):
    coords_dict[i] = tuple(coords_2d[i])


# Inserisco attributi all'inetrno di ogni nodo 
data = np.loadtxt(r"C:\Users\aliac\Desktop\Tesi_Magistrale\Esercitazione_CFD\cellcentered_to_node_1.txt")   # Apro il file txt generato dal codice python from_cell_centered_to_node.py
x, y, rho, P, u, v, M, S = data.T

for i in range(coords_2d.shape[0]):
    G.nodes[i]["x"] = x[i]
    G.nodes[i]["y"] = y[i]
    G.nodes[i]["densità"] = rho[i]
    G.nodes[i]["pressione"] = P[i]
    G.nodes[i]["u"] = u[i]
    G.nodes[i]["v"] = v[i]
    G.nodes[i]["mach"] = M[i]
    G.nodes[i]["entropia"] = S[i]

#print(G.nodes[0])


mach=[]
for i in G.nodes:
    mach.append(G.nodes[i]["mach"])




# Visualizzazione grafo

# Disegno nodi e archi in maniera separata per visualizzare la colorbar ( se scrivessi solo nx.draw() mi darebbe errore)

# Disegno i nodi 
nodes = nx.draw_networkx_nodes(
    G, pos=coords_dict,
    node_color=mach,      # lista di valori (uno per nodo) della variabile da visualizzare ( in questo caso il mach)
    cmap=plt.cm.jet,      
    node_size=100
)

# Disegno gli archi 
edges=nx.draw_networkx_edges(G, pos=coords_dict, edge_color="gray")


# Colorbar
cbar = plt.colorbar(nodes)
cbar.set_label("Mach")

plt.axis("equal")
plt.show()